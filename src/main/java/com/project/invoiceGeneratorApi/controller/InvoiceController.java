package com.project.invoiceGeneratorApi.controller;

import com.project.invoiceGeneratorApi.entity.Invoice;
import com.project.invoiceGeneratorApi.service.InvoiceService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.security.core.Authentication;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.server.ResponseStatusException;

import java.util.List;

@RestController      // Marks this class as a REST controller, capable of handling HTTP requests.
@RequiredArgsConstructor      // Lombok annotation for constructor injection (same as in service).
@RequestMapping("/api/invoices")   //  Base URL path for all endpoints in this controller. All routes will start with /api/invoices.
@Slf4j
public class InvoiceController {

    // Inject InvoiceService into the controller.
    private final InvoiceService invoiceService;

    @PostMapping
    // @RequestBody: Spring automatically converts the JSON request body into an Invoice Java object.
    public ResponseEntity<Invoice> saveInvoice(@RequestBody Invoice invoice, Authentication authentication) {

        // Get the authenticated user's Clerk ID from the Authentication object
        String authenticatedClerkId = authentication.getName();

        // Set the clerkId on the invoice object to ensure it's linked to the authenticated user
        invoice.setClerkId(authenticatedClerkId);

        // Call the service layer to save the invoice.
        Invoice savedInvoice = invoiceService.saveInvoice(invoice);

        //  Return a ResponseEntity with HTTP status OK (200) and the saved Invoice object in the body.
        // The savedInvoice object will include the '_id' generated by MongoDB if it was a new invoice.
        return ResponseEntity.ok(savedInvoice);
    }

    @GetMapping
    public ResponseEntity<List<Invoice>> fetchInvoices(Authentication authentication) {
        String clerkId = authentication.getName();
        log.info("Fetching invoices for clerkId: {}", clerkId);
        List<Invoice> invoices = invoiceService.fetchInvoices(clerkId);
        log.info("Returning {} invoices for clerkId: {}", invoices.size(), clerkId);
        log.debug("Invoices data: {}", invoices); // Log the actual list content
        return ResponseEntity.ok(invoices);
        //return ResponseEntity.ok(invoiceService.fetchInvoices(authentication.getName()));
    }

    //designed to handle requests for deleting a specific invoice.
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> removeInvoice(@PathVariable String id, Authentication authentication) {

//        if(authentication.getName() != null){
//            invoiceService.removeInvoice(id, authentication.getName());
//            return ResponseEntity.noContent().build();
//        }

        invoiceService.removeInvoice(id, authentication.getName());
        return ResponseEntity.noContent().build();

        //throw new ResponseStatusException(HttpStatus.FORBIDDEN, "User does not have permission to access this resource.");
    }

}
